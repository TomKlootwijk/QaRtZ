<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>QaRtZ AR Baked Deform Test</title>

    <!-- A-Frame -->
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>

    <!-- MindAR A-Frame (image targets) -->
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>

    <style>
      html, body { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; }
    </style>

    <script>
      // --- 3D fading circle texture (thin rim fade) ---
      function buildFadeCircleTexture() {
        const c = document.getElementById("fadeCircleTex");
        if (!c) return;
        const ctx = c.getContext("2d");
        const w = c.width, h = c.height;
        const cx = w / 2, cy = h / 2;
        const r = Math.min(w, h) / 2;

        ctx.clearRect(0, 0, w, h);

        // Hex: 425695 => rgb(66, 86, 149)
        // Thin rim fade: solid almost to edge, fade only near outer boundary
        const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
	// Solid color until near the edge
	grad.addColorStop(0.00, "rgba(66, 86, 149, 1)");
	grad.addColorStop(0.90, "rgba(66, 86, 149, 1)"); // <-- keep solid to 90%

	// Thin fade band to transparent
	grad.addColorStop(0.98, "rgba(66, 86, 149, 0.35)");
	grad.addColorStop(1.00, "rgba(66, 86, 149, 0)");

        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, w, h);
      }
      document.addEventListener("DOMContentLoaded", buildFadeCircleTexture);

      // --- Animation clip player ---
      AFRAME.registerComponent("gltf-clip-player", {
        schema: {
          clip: { type: "string", default: "" },
          loop: { type: "string", default: "repeat" },   // repeat | once
          timeScale: { type: "number", default: 1 },
          restartOnFound: { type: "boolean", default: true },
          pauseOnLost: { type: "boolean", default: true },
          debug: { type: "boolean", default: true }
        },

        init() {
          this.mixer = null;
          this.action = null;
          this._playing = false;
          this._model = null;

          this._targetEl = this._findMindarTarget(this.el);

          if (this._targetEl) {
            this._targetEl.addEventListener("targetFound", () => {
              this._playing = true;
              if (this.data.restartOnFound) this._restart();
            });
            this._targetEl.addEventListener("targetLost", () => {
              if (this.data.pauseOnLost) this._playing = false;
            });
            this._playing = false;
          } else {
            this._playing = true;
          }

          this.el.addEventListener("model-loaded", () => {
            this._model = this.el.getObject3D("mesh");
            if (!this._model) return;

            const clips = this._model.animations || [];
            if (this.data.debug) console.log("[gltf-clip-player] clips:", clips.map(c => c.name));

            let clip = null;
            const want = (this.data.clip || "").trim();
            if (want.length) clip = clips.find(c => c.name === want) || null;
            if (!clip && clips.length) clip = clips[0];

            if (!clip) {
              console.warn("[gltf-clip-player] No animation clips found in model.");
              return;
            }

            this.mixer = new THREE.AnimationMixer(this._model);
            this.action = this.mixer.clipAction(clip);

            if (this.data.loop === "once") {
              this.action.setLoop(THREE.LoopOnce, 1);
              this.action.clampWhenFinished = true;
            } else {
              this.action.setLoop(THREE.LoopRepeat, Infinity);
            }

            this.action.play();
            if (!this._playing) this.mixer.setTime(0);
          });
        },

        tick(time, timeDelta) {
          if (!this.mixer || !this.action) return;
          if (!this._playing) return;
          const dt = (timeDelta / 1000) * (this.data.timeScale || 1);
          if (dt > 0) this.mixer.update(dt);
        },

        _restart() {
          if (!this.mixer || !this.action) return;
          this.mixer.setTime(0);
          this.action.reset();
          this.action.play();
        },

        _findMindarTarget(el) {
          let cur = el.parentEl;
          while (cur) {
            if (cur.components && cur.components["mindar-image-target"]) return cur;
            cur = cur.parentEl;
          }
          return null;
        }
      });

      // --- Bright white + outline (safe: no recursive outlining) ---
      AFRAME.registerComponent("gltf-style", {
        schema: {
          color: { type: "color", default: "#FFFFFF" },
          emissive: { type: "color", default: "#FFFFFF" },
          emissiveIntensity: { type: "number", default: 0.6 }, // brighter

          roughness: { type: "number", default: 0.6 },
          metalness: { type: "number", default: 0.0 },

          outline: { type: "boolean", default: true },
          outlineColor: { type: "color", default: "#303E73" },
          outlineThickness: { type: "number", default: 0.03 }, // scale-up amount
          outlineOpacity: { type: "number", default: 1.0 },

          debug: { type: "boolean", default: false }
        },

        init() {
          this.el.addEventListener("model-loaded", () => this.apply());
        },

        apply() {
          const root = this.el.getObject3D("mesh");
          if (!root) return;

          const d = this.data;

          // Collect meshes BEFORE we add outline children (prevents recursion).
          const meshes = [];
          root.traverse((obj) => {
            if (!obj || !obj.isMesh) return;
            if (obj.userData && obj.userData.__isOutline) return; // skip outlines
            meshes.push(obj);
          });

          if (d.debug) {
            console.log("[gltf-style] meshes:", meshes.length);
            if (meshes[0]) console.log("[gltf-style] first isSkinnedMesh:", !!meshes[0].isSkinnedMesh);
          }

          const outlineMat = new THREE.MeshBasicMaterial({
            color: new THREE.Color(d.outlineColor),
            side: THREE.BackSide,
            transparent: d.outlineOpacity < 1.0,
            opacity: d.outlineOpacity,
            depthTest: true,
            depthWrite: true,
            polygonOffset: true,
            polygonOffsetFactor: 1,
            polygonOffsetUnits: 1
          });

          const white = new THREE.Color(d.color);
          const emis = new THREE.Color(d.emissive);

          for (const obj of meshes) {
            // 1) Force bright white
            if (Array.isArray(obj.material)) {
              obj.material = obj.material.map((m) => this._tintMaterial(m, white, emis, d));
            } else {
              obj.material = this._tintMaterial(obj.material, white, emis, d);
            }
            if (obj.material) obj.material.needsUpdate = true;

            // 2) Outline
            if (!d.outline) continue;
            if (obj.userData.__hasOutline) continue;
            obj.userData.__hasOutline = true;

            let outlineMesh;
            if (obj.isSkinnedMesh) {
              outlineMesh = new THREE.SkinnedMesh(obj.geometry, outlineMat);
              outlineMesh.bind(obj.skeleton, obj.bindMatrix);
            } else {
              outlineMesh = new THREE.Mesh(obj.geometry, outlineMat);
            }

            outlineMesh.userData.__isOutline = true;
            outlineMesh.frustumCulled = false;
            outlineMesh.renderOrder = (obj.renderOrder || 0) - 1;
            outlineMesh.scale.set(1 + d.outlineThickness, 1 + d.outlineThickness, 1 + d.outlineThickness);

            obj.add(outlineMesh);
          }
        },

        _tintMaterial(mat, white, emis, d) {
          if (!mat) return mat;

          // Clone so we don't mutate shared materials
          const m = mat.clone ? mat.clone() : mat;

          if (m.color) m.color.copy(white);

          // PBR emissive brightening
          if ("emissive" in m && m.emissive) {
            m.emissive.copy(emis);
            m.emissiveIntensity = d.emissiveIntensity;
          }

          if ("roughness" in m) m.roughness = d.roughness;
          if ("metalness" in m) m.metalness = d.metalness;

          return m;
        }
      });
    </script>
  </head>

  <body>
    <a-scene
      mindar-image="imageTargetSrc: ./targets.mind; autoStart: true;"
      vr-mode-ui="enabled: false"
      device-orientation-permission-ui="enabled: true"
      renderer="colorManagement: true; physicallyCorrectLights: true;"
    >
      <a-assets timeout="300000">
        <canvas id="fadeCircleTex" width="512" height="512"></canvas>
        <a-asset-item id="metronomeModel" src="./models/Metronome.glb" crossorigin="anonymous"></a-asset-item>
      </a-assets>

      <a-entity light="type: directional; intensity: 0.9" position="1 2 1"></a-entity>
      <a-entity light="type: ambient; intensity: 0.75"></a-entity>

      <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

      <a-entity mindar-image-target="targetIndex: 0">
        <!-- 3D background circle behind the metronome -->
        <a-entity
          id="bgCircle"
          geometry="primitive: circle; radius: 1.0; segments: 64"
          material="shader: flat; src: #fadeCircleTex; transparent: true; side: double; alphaTest: 0.01; depthWrite: false"
          position="0 0 -0.05"
          rotation="0 0 0"
        ></a-entity>

        <!-- Metronome -->
        <a-entity
          id="metronome"
          gltf-model="#metronomeModel"
          position="0 0 0"
          rotation="0 180 0"
          scale="1 1 1"
          gltf-style="
            color: #FFFFFF;
            emissive: #FFFFFF;
            emissiveIntensity: 0.6;
            roughness: 0.6;
            metalness: 0.0;
            outline: true;
            outlineColor: #303E73;
            outlineThickness: 0.03;
            outlineOpacity: 1.0;
            debug: false;
          "
          gltf-clip-player="
            clip: MetronomeSwing;
            loop: repeat;
            timeScale: 1;
            restartOnFound: true;
            pauseOnLost: true;
            debug: true;
          "
        ></a-entity>
      </a-entity>
    </a-scene>
  </body>
</html>
