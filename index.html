<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>QaRtZ AR Baked Deform Test</title>

    <!-- A-Frame -->
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>

    <!-- MindAR A-Frame (image targets) -->
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>

    <style>
      html, body { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; }
    </style>

    <script>
      // Build a radial fade texture in #425695 -> transparent, drawn once.
      function buildFadeCircleTexture() {
        const c = document.getElementById("fadeCircleTex");
        if (!c) return;
        const ctx = c.getContext("2d");
        const w = c.width, h = c.height;
        const cx = w / 2, cy = h / 2;
        const r = Math.min(w, h) / 2;

        ctx.clearRect(0, 0, w, h);

        // Hex: 425695 => rgb(66, 86, 149)
        const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
        grad.addColorStop(0.00, "rgba(66, 86, 149, 1)");
        grad.addColorStop(0.45, "rgba(66, 86, 149, 1)");
        grad.addColorStop(1.00, "rgba(66, 86, 149, 0)");

        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, w, h);
      }

      document.addEventListener("DOMContentLoaded", buildFadeCircleTexture);

      // Plays a named glTF clip using THREE.AnimationMixer (no aframe-extras dependency).
      AFRAME.registerComponent("gltf-clip-player", {
        schema: {
          clip: { type: "string", default: "" },
          loop: { type: "string", default: "repeat" },
          timeScale: { type: "number", default: 1 },
          restartOnFound: { type: "boolean", default: true },
          pauseOnLost: { type: "boolean", default: true },
          debug: { type: "boolean", default: false }
        },

        init() {
          this.mixer = null;
          this.action = null;
          this._playing = false;
          this._model = null;

          this._targetEl = this._findMindarTarget(this.el);

          if (this._targetEl) {
            this._targetEl.addEventListener("targetFound", () => {
              this._playing = true;
              if (this.data.restartOnFound) this._restart();
            });

            this._targetEl.addEventListener("targetLost", () => {
              if (this.data.pauseOnLost) this._playing = false;
            });

            this._playing = false; // start paused until found
          } else {
            this._playing = true;  // autoplay without marker
          }

          this.el.addEventListener("model-loaded", () => {
            this._model = this.el.getObject3D("mesh");
            if (!this._model) return;

            const clips = this._model.animations || [];
            if (this.data.debug) console.log("[gltf-clip-player] clips:", clips.map(c => c.name));

            let clip = null;
            const want = (this.data.clip || "").trim();
            if (want.length) clip = clips.find(c => c.name === want) || null;
            if (!clip && clips.length) clip = clips[0];

            if (!clip) {
              console.warn("[gltf-clip-player] No animation clips found in model.");
              return;
            }

            this.mixer = new THREE.AnimationMixer(this._model);
            this.action = this.mixer.clipAction(clip);

            if (this.data.loop === "once") {
              this.action.setLoop(THREE.LoopOnce, 1);
              this.action.clampWhenFinished = true;
            } else {
              this.action.setLoop(THREE.LoopRepeat, Infinity);
            }

            this.action.play();

            if (!this._playing) this.mixer.setTime(0);
          });
        },

        tick(time, timeDelta) {
          if (!this.mixer || !this.action) return;
          if (!this._playing) return;
          const dt = (timeDelta / 1000) * (this.data.timeScale || 1);
          if (dt > 0) this.mixer.update(dt);
        },

        _restart() {
          if (!this.mixer || !this.action) return;
          this.mixer.setTime(0);
          this.action.reset();
          this.action.play();
        },

        _findMindarTarget(el) {
          let cur = el.parentEl;
          while (cur) {
            if (cur.components && cur.components["mindar-image-target"]) return cur;
            cur = cur.parentEl;
          }
          return null;
        }
      });
    </script>
  </head>

  <body>
    <a-scene
      mindar-image="imageTargetSrc: ./targets.mind; autoStart: true;"
      vr-mode-ui="enabled: false"
      device-orientation-permission-ui="enabled: true"
      renderer="colorManagement: true; physicallyCorrectLights: true;"
    >
      <a-assets timeout="300000">
        <!-- Texture for the 3D fading circle -->
        <canvas id="fadeCircleTex" width="1024" height="1024"></canvas>

        <!-- Put Metronome.glb in ./models/ on your GitHub Pages site -->
        <a-asset-item id="metronomeModel" src="./models/Metronome.glb" crossorigin="anonymous"></a-asset-item>
      </a-assets>

      <a-entity light="type: directional; intensity: 0.8" position="1 2 1"></a-entity>
      <a-entity light="type: ambient; intensity: 0.6"></a-entity>

      <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

      <a-entity mindar-image-target="targetIndex: 0">

        <!-- 3D background circle behind the metronome -->
        <a-entity
          id="bgCircle"
          geometry="primitive: circle; radius: 1.1; segments: 64"
          material="shader: flat; src: #fadeCircleTex; transparent: true; side: double; alphaTest: 0.001; depthWrite: false"
          position="0 0 -0.05"
          rotation="0 0 0"
        ></a-entity>

        <!-- Metronome -->
        <a-entity
          id="metronome"
          gltf-model="#metronomeModel"
          position="0 0 0"
          rotation="0 180 0"
          scale="1 1 1"
          gltf-clip-player="
            clip: MetronomeSwing;
            loop: repeat;
            timeScale: 1;
            restartOnFound: true;
            pauseOnLost: true;
            debug: false;
          "
        ></a-entity>

      </a-entity>
    </a-scene>
  </body>
</html>
